package toolkitgen

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

var psFunctionLine = regexp.MustCompile(`(?i)^\s*function\s+([a-z0-9_-]+)\b`)

type InitOptions struct {
	Repo        string
	Name        string
	Prefix      string
	Category    string
	File        string
	Description string
	Force       bool
}

type AddOptions struct {
	Repo           string
	File           string
	Prefix         string
	FuncName       string
	Synopsis       string
	Description    string
	Confirm        bool
	Params         []string
	Switches       []string
	RequireVars    []string
	RequireHelpers []string
}

type Issue struct {
	Path string
	Line int
	Msg  string
}

type ValidateResult struct {
	Files   int
	Funcs   int
	Issues  []Issue
	RepoDir string
}

func Init(opts InitOptions) (string, error) {
	if strings.TrimSpace(opts.Name) == "" {
		return "", fmt.Errorf("name is required")
	}
	if strings.TrimSpace(opts.Prefix) == "" {
		return "", fmt.Errorf("prefix is required")
	}
	if !isSafeToken(opts.Prefix) {
		return "", fmt.Errorf("invalid prefix %q", opts.Prefix)
	}

	target := strings.TrimSpace(opts.File)
	if target == "" {
		filename := sanitizeTitle(opts.Name) + "_Toolkit.ps1"
		baseDir := filepath.Join(opts.Repo, "plugins", "functions")
		if strings.TrimSpace(opts.Category) != "" {
			baseDir = filepath.Join(baseDir, opts.Category)
		}
		target = filepath.Join(baseDir, filename)
	} else if !filepath.IsAbs(target) {
		target = filepath.Join(opts.Repo, target)
	}

	if err := os.MkdirAll(filepath.Dir(target), 0o755); err != nil {
		return "", err
	}
	if !opts.Force {
		if _, err := os.Stat(target); err == nil {
			return "", fmt.Errorf("file already exists: %s (use --force to overwrite)", target)
		}
	}

	desc := strings.TrimSpace(opts.Description)
	if desc == "" {
		desc = fmt.Sprintf("%s toolkit generated by dm", sanitizeTitle(opts.Name))
	}
	initialFunction := strings.ToLower(opts.Prefix) + "_info"
	content := renderToolkitFile(sanitizeTitle(opts.Name), strings.ToLower(opts.Prefix), desc, initialFunction)
	if err := os.WriteFile(target, []byte(content), 0o644); err != nil {
		return "", err
	}
	return target, nil
}

func Add(opts AddOptions) (string, error) {
	if strings.TrimSpace(opts.File) == "" {
		return "", fmt.Errorf("file is required")
	}
	if strings.TrimSpace(opts.Prefix) == "" {
		return "", fmt.Errorf("prefix is required")
	}
	if strings.TrimSpace(opts.FuncName) == "" {
		return "", fmt.Errorf("func is required")
	}
	if !isSafeToken(opts.Prefix) || !isSafeToken(opts.FuncName) {
		return "", fmt.Errorf("prefix/func must use letters numbers underscore")
	}

	target := opts.File
	if !filepath.IsAbs(target) {
		target = filepath.Join(opts.Repo, target)
	}

	data, err := os.ReadFile(target)
	if err != nil {
		return "", err
	}
	text := string(data)
	publicFn := strings.ToLower(opts.Prefix) + "_" + strings.ToLower(opts.FuncName)
	if functionExists(text, publicFn) {
		return "", fmt.Errorf("function already exists: %s", publicFn)
	}

	if opts.Confirm && !containsToken(opts.RequireHelpers, "_confirm_action") {
		opts.RequireHelpers = append(opts.RequireHelpers, "_confirm_action")
	}
	for _, h := range opts.RequireHelpers {
		if err := ensureHelper(opts.Repo, strings.TrimSpace(h)); err != nil {
			return "", err
		}
	}
	for _, v := range opts.RequireVars {
		name, def, err := parseVarSpec(v)
		if err != nil {
			return "", err
		}
		if err := ensureVariable(opts.Repo, name, def); err != nil {
			return "", err
		}
	}

	block := renderFunctionBlock(publicFn, opts.Synopsis, opts.Description, opts.Params, opts.Switches, opts.Confirm)
	if !strings.HasSuffix(text, "\n") {
		text += "\n"
	}
	text += "\n" + block
	if err := os.WriteFile(target, []byte(text), 0o644); err != nil {
		return "", err
	}
	return target, nil
}

func Validate(repo string) (ValidateResult, error) {
	functionsDir := filepath.Join(repo, "plugins", "functions")
	files, err := listPSFiles(functionsDir)
	if err != nil {
		return ValidateResult{}, err
	}
	res := ValidateResult{
		Files:   len(files),
		RepoDir: repo,
	}
	seen := map[string]string{}

	for _, file := range files {
		lines, err := readLines(file)
		if err != nil {
			res.Issues = append(res.Issues, Issue{Path: file, Line: 1, Msg: err.Error()})
			continue
		}
		hasStrict := false
		hasStop := false
		for _, line := range lines {
			trim := strings.TrimSpace(strings.ToLower(line))
			if trim == "set-strictmode -version latest" {
				hasStrict = true
			}
			if strings.Contains(trim, "$erroractionpreference") && strings.Contains(trim, "stop") {
				hasStop = true
			}
		}
		if !hasStrict {
			res.Issues = append(res.Issues, Issue{Path: file, Line: 1, Msg: "missing Set-StrictMode -Version Latest"})
		}
		if !hasStop {
			res.Issues = append(res.Issues, Issue{Path: file, Line: 1, Msg: "missing $ErrorActionPreference = \"Stop\""})
		}

		for i, line := range lines {
			m := psFunctionLine.FindStringSubmatch(line)
			if len(m) != 2 {
				continue
			}
			res.Funcs++
			fn := strings.TrimSpace(m[1])
			j := i - 1
			for j >= 0 && strings.TrimSpace(lines[j]) == "" {
				j--
			}
			if j < 0 || strings.TrimSpace(lines[j]) != "#>" {
				res.Issues = append(res.Issues, Issue{Path: file, Line: i + 1, Msg: "missing comment-based help block before function"})
			}
			if strings.HasPrefix(fn, "_") {
				continue
			}
			key := strings.ToLower(fn)
			if prev, ok := seen[key]; ok {
				res.Issues = append(res.Issues, Issue{
					Path: file, Line: i + 1,
					Msg: fmt.Sprintf("duplicate public function '%s' (already in %s)", fn, prev),
				})
				continue
			}
			seen[key] = file
		}
	}

	sort.Slice(res.Issues, func(i, j int) bool {
		if res.Issues[i].Path == res.Issues[j].Path {
			return res.Issues[i].Line < res.Issues[j].Line
		}
		return res.Issues[i].Path < res.Issues[j].Path
	})
	return res, nil
}

func renderToolkitFile(name, prefix, description, initialFn string) string {
	return strings.Join([]string{
		"# =============================================================================",
		fmt.Sprintf("# %s TOOLKIT - %s", strings.ToUpper(name), description),
		"# Generated by dm",
		"# Entry point: " + prefix + "_*",
		"#",
		"# FUNCTIONS",
		"#   " + initialFn,
		"# =============================================================================",
		"",
		"Set-StrictMode -Version Latest",
		`$ErrorActionPreference = "Stop"`,
		"",
		"<#",
		".SYNOPSIS",
		"Show toolkit information.",
		".DESCRIPTION",
		"Starter function generated by dm.",
		".EXAMPLE",
		"dm " + initialFn,
		"#>",
		"function " + initialFn + " {",
		"    [pscustomobject]@{",
		"        Toolkit = " + quotePS(name),
		"        Prefix  = " + quotePS(prefix),
		"        Status  = " + quotePS("ready"),
		"    }",
		"}",
		"",
	}, "\n")
}

func renderFunctionBlock(name, synopsis, description string, params, switches []string, withConfirm bool) string {
	if strings.TrimSpace(synopsis) == "" {
		synopsis = "Invoke " + name + "."
	}
	if strings.TrimSpace(description) == "" {
		description = "Generated function scaffold."
	}
	lines := []string{"<#", ".SYNOPSIS", synopsis, ".DESCRIPTION", description}
	for _, p := range params {
		p = strings.TrimSpace(p)
		if p != "" {
			lines = append(lines, ".PARAMETER "+p, "Parameter "+p+".")
		}
	}
	for _, s := range switches {
		s = strings.TrimSpace(s)
		if s != "" {
			lines = append(lines, ".PARAMETER "+s, "Switch "+s+".")
		}
	}
	if withConfirm {
		lines = append(lines, ".PARAMETER Force", "Skip interactive confirmation.")
	}
	lines = append(lines, ".EXAMPLE", "dm "+name, "#>", "function "+name+" {")

	var paramLines []string
	for _, p := range params {
		p = strings.TrimSpace(p)
		if p != "" {
			paramLines = append(paramLines, "        [Parameter(Mandatory = $true)][string]$"+p)
		}
	}
	for _, s := range switches {
		s = strings.TrimSpace(s)
		if s != "" {
			paramLines = append(paramLines, "        [switch]$"+s)
		}
	}
	if withConfirm {
		paramLines = append(paramLines, "        [switch]$Force")
	}
	if len(paramLines) > 0 {
		lines = append(lines, "    param(")
		for i, pl := range paramLines {
			if i < len(paramLines)-1 {
				lines = append(lines, pl+",")
			} else {
				lines = append(lines, pl)
			}
		}
		lines = append(lines, "    )", "")
	}
	if withConfirm {
		lines = append(lines,
			"    if (-not $Force) {",
			"        if (-not (_confirm_action -Prompt "+quotePS("Continue with "+name+"?")+")) {",
			"            Write-Output "+quotePS("Operation cancelled."),
			"            return",
			"        }",
			"    }",
			"",
		)
	}
	lines = append(lines, "    Write-Output "+quotePS("TODO: implement "+name), "}")
	return strings.Join(lines, "\n")
}

func isSafeToken(v string) bool {
	ok, _ := regexp.MatchString(`^[A-Za-z0-9_]+$`, strings.TrimSpace(v))
	return ok
}

func sanitizeTitle(v string) string {
	s := strings.TrimSpace(v)
	if s == "" {
		return "Toolkit"
	}
	var b strings.Builder
	for _, r := range s {
		if (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '_' || r == '-' {
			b.WriteRune(r)
		}
	}
	if out := b.String(); out != "" {
		return out
	}
	return "Toolkit"
}

func functionExists(text, functionName string) bool {
	re := regexp.MustCompile(`(?im)^\s*function\s+` + regexp.QuoteMeta(functionName) + `\b`)
	return re.FindStringIndex(text) != nil
}

func containsToken(list []string, token string) bool {
	token = strings.ToLower(strings.TrimSpace(token))
	for _, it := range list {
		if strings.ToLower(strings.TrimSpace(it)) == token {
			return true
		}
	}
	return false
}

func parseVarSpec(spec string) (string, string, error) {
	parts := strings.SplitN(spec, "=", 2)
	if len(parts) != 2 {
		return "", "", fmt.Errorf("invalid require-var %q, use NAME=default", spec)
	}
	name := strings.TrimSpace(parts[0])
	def := strings.TrimSpace(parts[1])
	if !isSafeToken(name) {
		return "", "", fmt.Errorf("invalid variable name %q", name)
	}
	return name, def, nil
}

func ensureHelper(repoRoot, helperName string) error {
	path := filepath.Join(repoRoot, "plugins", "utils.ps1")
	content, err := readOrInitSharedPS(path)
	if err != nil {
		return err
	}
	if functionExists(content, helperName) {
		return nil
	}
	block, ok := helperTemplates()[helperName]
	if !ok {
		return fmt.Errorf("unknown helper template: %s", helperName)
	}
	if !strings.HasSuffix(content, "\n") {
		content += "\n"
	}
	content += "\n" + block + "\n"
	return os.WriteFile(path, []byte(content), 0o644)
}

func ensureVariable(repoRoot, name, defaultValue string) error {
	path := filepath.Join(repoRoot, "plugins", "variables.ps1")
	content, err := readOrInitSharedPS(path)
	if err != nil {
		return err
	}
	if !functionExists(content, "_env_or_default") {
		if !strings.HasSuffix(content, "\n") {
			content += "\n"
		}
		content += "\n" + envOrDefaultBlock() + "\n"
	}
	assignRe := regexp.MustCompile(`(?im)^\s*\$script:` + regexp.QuoteMeta(name) + `\s*=`)
	if assignRe.FindStringIndex(content) != nil {
		return os.WriteFile(path, []byte(content), 0o644)
	}

	begin := "# region dm-toolkit:variables"
	end := "# endregion dm-toolkit:variables"
	if !strings.Contains(content, begin) || !strings.Contains(content, end) {
		if !strings.HasSuffix(content, "\n") {
			content += "\n"
		}
		content += "\n" + begin + "\n" + end + "\n"
	}
	assign := strings.Join([]string{
		"$script:" + name + " = _env_or_default `",
		"    -Name " + quotePS(name) + " `",
		"    -Default " + quotePS(defaultValue),
	}, "\n")
	content = strings.Replace(content, begin+"\n", begin+"\n"+assign+"\n\n", 1)
	return os.WriteFile(path, []byte(content), 0o644)
}

func readOrInitSharedPS(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err == nil {
		return string(data), nil
	}
	if !os.IsNotExist(err) {
		return "", err
	}
	base := "Set-StrictMode -Version Latest\n$ErrorActionPreference = \"Stop\"\n\n"
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return "", err
	}
	if err := os.WriteFile(path, []byte(base), 0o644); err != nil {
		return "", err
	}
	return base, nil
}

func envOrDefaultBlock() string {
	return strings.Join([]string{
		"<#", ".SYNOPSIS", "Resolve environment variable with fallback default.", ".PARAMETER Name",
		"Environment variable name.", ".PARAMETER Default", "Fallback value when env var is empty.", ".EXAMPLE",
		"_env_or_default -Name \"DM_EXAMPLE\" -Default \"value\"", "#>",
		"function _env_or_default {",
		"    param(",
		"        [Parameter(Mandatory = $true)][string]$Name,",
		"        [Parameter(Mandatory = $true)][string]$Default",
		"    )", "",
		"    $value = [Environment]::GetEnvironmentVariable($Name)",
		"    if ([string]::IsNullOrWhiteSpace($value)) {",
		"        return $Default",
		"    }",
		"    return $value",
		"}",
	}, "\n")
}

func helperTemplates() map[string]string {
	return map[string]string{
		"_assert_command_available": "<#\n.SYNOPSIS\nEnsure a command is available in PATH.\n.PARAMETER Name\nExecutable/command name.\n.EXAMPLE\n_assert_command_available -Name docker\n#>\nfunction _assert_command_available {\n    param([Parameter(Mandatory = $true)][string]$Name)\n    if (-not (Get-Command -Name $Name -ErrorAction SilentlyContinue)) {\n        throw \"Required command '$Name' was not found in PATH.\"\n    }\n}",
		"_assert_path_exists":       "<#\n.SYNOPSIS\nEnsure a filesystem path exists.\n.PARAMETER Path\nFilesystem path to validate.\n.EXAMPLE\n_assert_path_exists -Path C:\\temp\n#>\nfunction _assert_path_exists {\n    param([Parameter(Mandatory = $true)][string]$Path)\n    if (-not (Test-Path -LiteralPath $Path)) {\n        throw \"Required path '$Path' does not exist.\"\n    }\n}",
		"_confirm_action":           "<#\n.SYNOPSIS\nAsk for a yes/no confirmation before a risky action.\n.PARAMETER Prompt\nMessage shown to the user.\n.EXAMPLE\nif (-not (_confirm_action -Prompt \"Continue?\")) { return }\n#>\nfunction _confirm_action {\n    param([Parameter(Mandatory = $true)][string]$Prompt)\n    $answer = Read-Host \"$Prompt [y/N]\"\n    if ([string]::IsNullOrWhiteSpace($answer)) {\n        return $false\n    }\n    return $answer.Trim().ToLowerInvariant() -in @(\"y\", \"yes\")\n}",
	}
}

func listPSFiles(root string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(root, func(path string, d os.DirEntry, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}
		if d.IsDir() {
			return nil
		}
		ext := strings.ToLower(filepath.Ext(d.Name()))
		if ext == ".ps1" || ext == ".psm1" || ext == ".txt" {
			files = append(files, path)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	sort.Strings(files)
	return files, nil
}

func readLines(path string) ([]string, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	var out []string
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		out = append(out, sc.Text())
	}
	return out, sc.Err()
}

func quotePS(v string) string {
	return "'" + strings.ReplaceAll(v, "'", "''") + "'"
}
